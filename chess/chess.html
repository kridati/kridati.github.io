<!DOCTYPE html>
<html>

<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1QSWB91R8H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1QSWB91R8H');
</script>
<!-- google adsense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5879206576649841"
     crossorigin="anonymous"></script>
    <title>Chess Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:image" content="img/share.jpeg" />
    <meta property="og:description"
        content="A complete well automated chess game made by JavaScript that contains AI. Check it out. I hope you like it." />
    
    <link rel="icon" type="image/x-icon" href="favicon.ico">

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #1D434F;
background: -webkit-linear-gradient(90deg, rgba(29, 67, 79, 1) 0%, rgba(40, 130, 158, 1) 23%, rgba(29, 67, 79, 1) 50%, rgba(40, 130, 158, 1) 78%, rgba(29, 67, 79, 1) 100%);
background: -moz-linear-gradient(90deg, rgba(29, 67, 79, 1) 0%, rgba(40, 130, 158, 1) 23%, rgba(29, 67, 79, 1) 50%, rgba(40, 130, 158, 1) 78%, rgba(29, 67, 79, 1) 100%);
background: linear-gradient(90deg, rgba(29, 67, 79, 1) 0%, rgba(40, 130, 158, 1) 23%, rgba(29, 67, 79, 1) 50%, rgba(40, 130, 158, 1) 78%, rgba(29, 67, 79, 1) 100%);
filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#1D434F", endColorstr="#1D434F", GradientType=1);
            height: 100vh;
            justify-content: center;
            display: flex;
        }

        .board-container {
            width: 600px;
            max-width: 90%;
            justify-content: center;
            margin: auto;
            position: relative;
        }

        .semataries {
            width: 100%;
            margin: auto;
            display: flex;
            justify-content: center;
        }

        .sematary {
            width: 50%;
        }

        #blackSematary {
            text-align: right;
        }

        #board {
            aspect-ratio: 1 / 1;
            margin: auto;
            border: 3px #333 solid;
        }

        #board div div {
            float: left;
            width: calc(100% / 8);
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            border: #000 solid .01cm;
        }

        #board .even div:nth-child(even) {
            background: #ccd;
        }

        #board .even div:nth-child(odd) {
            background: rgb(112, 112, 112);
            /*621700*/
        }

        #board .odd div:nth-child(even) {
            background: rgb(112, 112, 112);
            /*621700*/
        }

        #board .odd div:nth-child(odd) {
            background: #ccd;
        }

        .animate {
            animation: rotateBoard 1s ease-out;
            animation-fill-mode: both;
        }

        @keyframes rotateBoard {
            0% {
                transform: rotateZ(0);
            }

            100% {
                transform: rotateZ(-180deg);
            }

        }

        .forward {
            transform: rotateZ(-180deg);
        }

        .backward {
            transform: rotateZ(0);
        }

        .animate-backward {
            animation: rotateBoardBackward 1s ease-out;
            animation-fill-mode: both;
        }

        @keyframes rotateBoardBackward {
            0% {
                transform: rotateZ(-180deg);
            }

            100% {
                transform: rotateZ(0);
            }

        }

        img.piece {
            width: 100%;
            height: 100%;
            float: left;
        }

        .allowed {
            opacity: .8;
            background: radial-gradient(#333, #222) !important;
            /*-webkit-box-shadow: inset 1px -4px 92px 0px rgba(0,0,0,0.75);
            -moz-box-shadow: inset 1px -4px 92px 0px rgba(0,0,0,0.75);
            box-shadow: inset 1px -4px 92px 0px rgba(0,0,0,0.75);*/
            border: 1px solid black !important;
        }

        .last-move {
            background: #30b030 !important;
        }

        .clicked-square {
            background: radial-gradient(#333, #222) !important;
            border: 1px solid black !important;
        }

        .sematary img {
            transform: rotateZ(0);
            width: 1.8rem;
            height: 1.8rem;
        }

        #blackSematary div {
            overflow-y: auto;
            margin-bottom: 2px;
        }

        .scene {
            position: relative;
            opacity: 0;
            display: none;
            z-index: 1;
        }

        .overlay {
            position: fixed;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: .7;
            z-index: 1;
        }

        .scene .scene-content {
            position: fixed;
            color: #fff;
            z-index: 2;
            width: 100%;
            text-align: center;
            margin-top: 40vh;
            font-size: 40px;
            height: 100vh;
        }

        .scene-content h2 {
            font-weight: 500;
            margin-bottom: 15px;
        }

        @media screen and (max-width: 600px) {
            .scene-content h2 {
                font-size: 2rem;
            }
        }

        .show {
            display: block !important;
            animation: showMessage 1s ease-out;
            animation-fill-mode: both;
        }

        .hidden {
            display: none;
        }

        @keyframes showMessage {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }

        }

        #turn {
            text-align: center;
            font-size: 18px;
        }

        .winning-sign:first-letter {
            text-transform: uppercase;
        }

        .flip-board {
            padding: 10px 20px;
            border-radius: 5px !important;
            outline: 0;
            background: #7f979e;
            color: white;
            border: 0;
        }


        input[type="radio"] {
            display: none;
        }

        label {
            background-color: rgb(112, 112, 112);
            position: relative;
            font-family: "Poppins", sans-serif;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.8em;
            padding: 1em 2em;
            border-radius: 0.5em;
            font-size: 23px;
        }

        input[type="radio"]:checked+label {
            background-color: #4189e0;
            color: #ffffff;
        }

        .button {
            background-color: rgb(112, 112, 112);
            border-radius: 10px;
            border: none;
            color: white;
            padding: 20px 40px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            cursor: pointer;
        }

        .button:hover,
        label:hover {
            background-color: rgb(160, 160, 160);
        }

        .button-big {
            padding: 30px 60px;
            font-size: 25px;
        }
    </style>
</head>

<body>

    <div id="startscene" class="scene show">
        <div class="scene-content" style="margin-top: 15vh;">
            <div style="margin-bottom: 50px;">
                <h2>Play Against</h2>
                <input type="radio" name="oponent" id="humanOponent" value="human" onchange="changeColorSelect()"
                    checked>
                <label for="humanOponent">Human</label>
                &ensp;
                <input type="radio" name="oponent" id="aiOponent" value="ai" onchange="changeColorSelect()">
                <label for="aiOponent">AI</label>
            </div>

            <div class="select-color-container" style="margin-bottom: 50px;display: none;">
                <h2>Select Your Color</h2>
                <input type="radio" name="human_color" id="humanColorWhite" value="white" checked>
                <label for="humanColorWhite">White</label>
                &ensp;
                <input type="radio" name="human_color" id="humanColorBlack" value="black">
                <label for="humanColorBlack">Black</label>
            </div>

            <div class="start-game-container">
                <button class="button button-big" onclick="startNewGame()">Start Game</button>
            </div>
        </div>
        <div class="overlay"></div>
    </div>

    <div id="endscene" class="scene">
        <p class="scene-content winning-sign"></p>
        <div class="overlay"></div>
    </div>

    <br>
    <div class="board-container">

        <div id="board">
            <div id="final" class="odd">
                <div id="81" class="square" data-square="8-a">
                    <img class="piece rook" id="blackRook1" src="img/black-rook.webp">
                </div>
                <div id="82" class="square" data-square="8-b">
                    <img class="piece knight" id="blackKnight1" src="img/black-knight.webp">
                </div>
                <div id="83" class="square" data-square="8-c">
                    <img class="piece bishop" id="blackBishop1" data-color="black" src="img/black-bishop.webp">
                </div>
                <div id="84" class="square" data-square="8-d">
                    <img class="piece bking" id="blackQueen" data-color="black" src="img/black-queen.webp">
                </div>
                <div id="85" class="square" data-square="8-e">
                    <img class="piece bking" id="blackKing" data-color="black" src="img/black-king.webp">
                </div>
                <div id="86" class="square" data-square="8-f">
                    <img class="piece bishop" id="blackBishop2" data-color="black" src="img/black-bishop.webp">
                </div>
                <div id="87" class="square" data-square="8-g">
                    <img class="piece bking" id="blackKnight2" data-color="black" src="img/black-knight.webp">
                </div>
                <div id="88" class="square" data-square="8-h">
                    <img class="piece rook" id="blackRook2" src="img/black-rook.webp">
                </div>
            </div>
            <div class="even">
                <div id="71" class="square" data-square="7-a">
                    <img class="piece pawn" id="blackPawn1" src="img/black-pawn.webp">
                </div>
                <div id="72" class="square" data-square="7-b">
                    <img class="piece pawn" id="blackPawn2" src="img/black-pawn.webp">
                </div>
                <div id="73" class="square" data-square="7-c">
                    <img class="piece pawn" id="blackPawn3" src="img/black-pawn.webp">
                </div>
                <div id="74" class="square" data-square="7-d">
                    <img class="piece pawn" id="blackPawn4" src="img/black-pawn.webp">
                </div>
                <div id="75" class="square" data-square="7-e">
                    <img class="piece pawn" id="blackPawn5" src="img/black-pawn.webp">
                </div>
                <div id="76" class="square" data-square="7-f">
                    <img class="piece pawn" id="blackPawn6" src="img/black-pawn.webp">
                </div>
                <div id="77" class="square" data-square="7-g">
                    <img class="piece pawn" id="blackPawn7" src="img/black-pawn.webp">
                </div>
                <div id="78" class="square" data-square="7-h">
                    <img class="piece pawn" id="blackPawn8" src="img/black-pawn.webp">
                </div>
            </div>
            <div class="odd">
                <div id="61" class="square" data-square="6-a"></div>
                <div id="62" class="square" data-square="6-b"></div>
                <div id="63" class="square" data-square="6-c"></div>
                <div id="64" class="square" data-square="6-d"></div>
                <div id="65" class="square" data-square="6-e"></div>
                <div id="66" class="square" data-square="6-f"></div>
                <div id="67" class="square" data-square="6-g"></div>
                <div id="68" class="square" data-square="6-h"></div>
            </div>
            <div class="even">
                <div id="51" class="square" data-square="5-a"></div>
                <div id="52" class="square" data-square="5-b"></div>
                <div id="53" class="square" data-square="5-c"></div>
                <div id="54" class="square" data-square="5-d"></div>
                <div id="55" class="square" data-square="5-e"></div>
                <div id="56" class="square" data-square="5-f"></div>
                <div id="57" class="square" data-square="5-g"></div>
                <div id="58" class="square" data-square="5-h"></div>
            </div>
            <div class="odd">
                <div id="41" class="square" data-square="4-a"></div>
                <div id="42" class="square" data-square="4-b"></div>
                <div id="43" class="square" data-square="4-c"></div>
                <div id="44" class="square" data-square="4-d"></div>
                <div id="45" class="square" data-square="4-e"></div>
                <div id="46" class="square" data-square="4-f"></div>
                <div id="47" class="square" data-square="4-g"></div>
                <div id="48" class="square" data-square="4-h"></div>
            </div>
            <div class="even">
                <div id="31" class="square" data-square="3-a"></div>
                <div id="32" class="square" data-square="3-b"></div>
                <div id="33" class="square" data-square="3-c"></div>
                <div id="34" class="square" data-square="3-d"></div>
                <div id="35" class="square" data-square="3-e"></div>
                <div id="36" class="square" data-square="3-f"></div>
                <div id="37" class="square" data-square="3-g"></div>
                <div id="38" class="square" data-square="3-h"></div>
            </div>
            <div class="odd">
                <div class="square white" id="21" data-square="2-a">
                    <img class="piece pawn" id="whitePawn1" src="img/white-pawn.webp">
                </div>
                <div class="square white" id="22" data-square="2-b">
                    <img class="piece pawn" id="whitePawn2" src="img/white-pawn.webp">
                </div>
                <div class="square white" id="23" data-square="2-c">
                    <img class="piece pawn" id="whitePawn3" src="img/white-pawn.webp">
                </div>
                <div class="square white" id="24" data-square="2-d">
                    <img class="piece pawn" id="whitePawn4" src="img/white-pawn.webp">
                </div>
                <div id="25" class="square white" data-square="2-e">
                    <img class="piece pawn" id="whitePawn5" src="img/white-pawn.webp">
                </div>
                <div id="26" class="square white" data-square="2-f">
                    <img class="piece pawn" id="whitePawn6" src="img/white-pawn.webp">
                </div>
                <div id="27" class="square white" data-square="2-g">
                    <img class="piece pawn" id="whitePawn7" src="img/white-pawn.webp">
                </div>
                <div id="28" class="square white" data-square="2-h">
                    <img class="piece pawn" id="whitePawn8" src="img/white-pawn.webp">
                </div>
            </div>
            <div class="even">
                <div id="11" class="square white" data-square="1-a">
                    <img class="piece rook" id="whiteRook1" src="img/white-rook.webp">
                </div>
                <div id="12" class="square white" data-square="1-b">
                    <img class="piece knight" id="whiteKnight1" src="img/white-knight.webp">
                </div>
                <div id="13" class="square white" data-square="1-c">
                    <img class="piece bishop" id="whiteBishop1" data-color="white" src="img/white-bishop.webp">
                </div>
                <div id="14" class="square white" data-square="1-d">
                    <img class="piece queen" id="whiteQueen" src="img/white-queen.webp">
                </div>
                <div id="15" class="square white" data-square="1-e">
                    <img class="piece wking" src="img/white-king.webp" class="white" id="whiteKing">
                </div>
                <div id="16" class="square white" data-square="1-f">
                    <img class="piece bishop" id="whiteBishop2" src="img/white-bishop.webp">
                </div>
                <div id="17" class="square white" data-square="1-g">
                    <img class="piece knight" id="whiteKnight2" src="img/white-knight.webp">
                </div>
                <div id="18" class="square white" data-square="1-h">
                    <img class="piece rook" id="whiteRook2" src="img/white-rook.webp">
                </div>
            </div>
        </div>

        <p id="turn">White's Turn</p>

        <div class="semataries">
            <div id="whiteSematary" class="sematary">
                <div class="pawn"></div>
                <div class="knight"></div>
                <div class="bishop"></div>
                <div class="rook"></div>
                <div class="queen"></div>
            </div>

            <div id="blackSematary" class="sematary">
                <div class="pawn"></div>
                <div class="knight"></div>
                <div class="bishop"></div>
                <div class="rook"></div>
                <div class="queen"></div>
            </div>
        </div>

    </div>

    <div style="position:absolute;left:15px;bottom:15px;">
        <button class="flip-board" onclick="boardAnimate()">Flip Board</button>
    </div>

    <script type="text/javascript">
        // --- piece.js content ---
        const changePosition = (piece, position, castle = false) => {
            piece.position = position;

            if (piece.rank === 'king') {
                if (castle) {
                    piece.ableToCastle = false;
                }
            }

            if (piece.rank === 'rook') {
                piece.ableToCastle = false;
            }

        }

        const getMovesTop = (piece) => {
            const movesTop = [];
            for (let move = piece.position + 10; move <= 88; move += 10) movesTop.push(move);
            return movesTop;
        }

        const getMovesBottom = (piece) => {
            const movesBottom = [];
            for (let move = piece.position - 10; move >= 11; move -= 10) movesBottom.push(move);
            return movesBottom;
        }

        const getMovesRight = (piece) => {
            const num = piece.position + '';
            const movesRight = [];
            for (let move = piece.position + 1; move <= parseInt(num[0] + '8'); move++) movesRight.push(move);
            return movesRight;
        }

        const getMovesLeft = (piece) => {
            const num = piece.position + '';
            const movesLeft = [];
            for (let move = piece.position - 1; move >= parseInt(num[0] + '1'); move--) movesLeft.push(move);
            return movesLeft;
        }

        const getMovesTopRight = (piece) => {
            const movesTopRight = [];
            for (let move = piece.position + 11; move <= 88; move += 11) {
                const firstDigit = ('' + move)[1];
                if (firstDigit > 8 || firstDigit < 1) break;
                movesTopRight.push(move);
            }
            return movesTopRight;
        }

        const getMovesTopLeft = (piece) => {
            const movesTopLeft = [];
            for (let move = piece.position + 9; move <= 88; move += 9) {
                const firstDigit = ('' + move)[1];
                if (firstDigit > 8 || firstDigit < 1) break;
                movesTopLeft.push(move);
            }
            return movesTopLeft;
        }

        const getMovesBottomRight = (piece) => {
            const movesBottomRight = [];
            for (let move = piece.position - 9; move >= 11; move -= 9) {
                const firstDigit = ('' + move)[1];
                if (firstDigit > 8 || firstDigit < 1) break;
                movesBottomRight.push(move);
            }
            return movesBottomRight;
        }

        const getMovesBottomLeft = (piece) => {
            const movesBottomLeft = [];
            for (let move = piece.position - 11; move >= 11; move -= 11) {
                const firstDigit = ('' + move)[1];
                if (firstDigit > 8 || firstDigit < 1) break;
                movesBottomLeft.push(move);
            }
            return movesBottomLeft;
        }

        const getPawnAllowedMoves = (pawn) => {
            const position = pawn.position;
            const mathSign = (pawn.color === 'white') ? 1 : -1;
            const allowedMoves = [position + mathSign * 10];

            if ((position > 20 && position < 29) || (position > 70 && position < 79)) {
                allowedMoves.push(position + mathSign * 20);
            }

            const attackMoves = [position + mathSign * 9, position + mathSign * 11];
            return [attackMoves, allowedMoves];
        }

        const getKnightAllowedMoves = (knight) => {
            const position = knight.position;
            return [
                [position + 21],
                [position - 21],
                [position + 19],
                [position - 19],
                [position + 12],
                [position - 12],
                [position + 8],
                [position - 8]
            ];
        }

        const getKingAllowedMoves = king => {
            const position = king.position;
            return [
                [position + 1],
                [position - 1],
                [position + 10],
                [position - 10],
                [position + 11],
                [position - 11],
                [position + 9],
                [position - 9]
            ];
        }

        const getBishopAllowedMoves = (bishop) => {
            return [getMovesTopRight(bishop), getMovesTopLeft(bishop), getMovesBottomRight(bishop), getMovesBottomLeft(bishop)];
        }

        const getRookAllowedMoves = (rook) => {
            return [getMovesTop(rook), getMovesBottom(rook), getMovesRight(rook), getMovesLeft(rook)];
        }

        const getQueenAllowedMoves = queen => {
            return [
                getMovesTop(queen),
                getMovesTopRight(queen),
                getMovesTopLeft(queen),
                getMovesBottom(queen),
                getMovesBottomRight(queen),
                getMovesBottomLeft(queen),
                getMovesRight(queen),
                getMovesLeft(queen)
            ];
        }

        const getAllowedMoves = (piece) => {
            let allowedMoves;

            switch (piece.rank) {
                case 'pawn':
                    allowedMoves = getPawnAllowedMoves(piece);
                    break;
                case 'knight':
                    allowedMoves = getKnightAllowedMoves(piece);
                    break;
                case 'king':
                    allowedMoves = getKingAllowedMoves(piece);
                    break;
                case 'bishop':
                    allowedMoves = getBishopAllowedMoves(piece);
                    break;
                case 'rook':
                    allowedMoves = getRookAllowedMoves(piece);
                    break;
                case 'queen':
                    allowedMoves = getQueenAllowedMoves(piece);
                    break;
                default:
                    throw "Unknown rank: " + piece.type;
            }

            return allowedMoves;
        }

        // --- History.js content ---
        class History {

            constructor() {
                this._lastStep = [];
                this._history = [];
            }

            add(step) {
                this._lastStep.push(step);
            }

            save() {
                this._history.push(this._lastStep);
                this._lastStep = [];
            }

            pop() {
                return this._history.pop();
            }

            lastMove() {
                return this._history[this._history.length - 1];
            }
        }

        // --- Game.js content ---
        class Game {
            constructor(pieces, turn) {
                this.startNewGame(pieces, turn);
            }

            startNewGame(pieces, turn) {
                this._setPieces(pieces);

                this.turn = turn;
                this.clickedPiece = null;
                this._events = {
                    pieceMove: [],
                    kill: [],
                    check: [],
                    promotion: [],
                    checkMate: [],
                    turnChange: []
                }
                this.history = new History();
            }

            _setPieces(pieces) {
                this.pieces = Array(pieces.length);
                pieces.forEach((piece, i) => {
                    this.pieces[i] = { rank: piece.rank, position: piece.position, color: piece.color, name: piece.name, ableToCastle: piece.ableToCastle }
                });
                this.playerPieces = {
                    white: this.pieces.filter(piece => piece.color === 'white'),
                    black: this.pieces.filter(piece => piece.color === 'black')
                }
            }

            _removePiece(piece) {
                this.pieces.splice(this.pieces.indexOf(piece), 1);
                this.playerPieces[piece.color].splice(this.playerPieces[piece.color].indexOf(piece), 1)
            }

            _addPiece(piece) {
                this.pieces.push(piece);
                this.playerPieces[piece.color].push(piece);
            }

            saveHistory() {
                this.history.save();
            }

            addToHistory(move) {
                this.history.add(move);
            }

            clearEvents() {
                this._events = {};
            }

            undo() {
                const step = this.history.pop();

                if (!step) {
                    return false;
                }

                for (const subStep of step) {
                    changePosition(subStep.piece, subStep.from);
                    if (subStep.from !== 0) {
                        if (subStep.to === 0) {
                            this._addPiece(subStep.piece);
                        }
                        else if (subStep.castling) {
                            subStep.piece.ableToCastle = true;
                        }
                        this.triggerEvent('pieceMove', subStep);
                    }
                    else {
                        this._removePiece(subStep.piece);
                        this.triggerEvent('kill', subStep.piece);
                    }

                    if (subStep.from !== 0 && subStep.to !== 0 && (!subStep.castling || subStep.piece.rank === 'king')) {
                        this.softChangeTurn();
                    }
                }
            }

            on(eventName, callback) {
                if (this._events[eventName] && typeof callback === 'function') {
                    this._events[eventName].push(callback);
                }
            }

            softChangeTurn() {
                this.turn = this.turn === 'white' ? 'black' : 'white';
                this.triggerEvent('turnChange', this.turn);
            }

            changeTurn() {
                this.softChangeTurn();
                this.saveHistory();
            }

            getPiecesByColor(color) {
                return this.playerPieces[color];
            }

            getPlayerPositions(color) {
                return this.getPiecesByColor(color).map(piece => piece.position);
            }

            filterPositions(positions) {
                return positions.filter(pos => {
                    const x = pos % 10;
                    return pos > 10 && pos < 89 && x !== 9 && x !== 0;
                });
            };

            unblockedPositions(piece, allowedPositions, checking = true) {
                const unblockedPositions = [];

                const myColor = piece.color;
                const otherColor = piece.color === 'white' ? 'black' : 'white';

                const myBlockedPositions = this.getPlayerPositions(myColor);
                const otherBlockedPositions = this.getPlayerPositions(otherColor);

                if (piece.rank === 'pawn') {
                    for (const move of allowedPositions[0]) { //attacking moves
                        if (checking && this.myKingChecked(move)) continue;
                        if (otherBlockedPositions.indexOf(move) !== -1) unblockedPositions.push(move);
                    }

                    for (const move of allowedPositions[1]) { //moving moves
                        if (myBlockedPositions.indexOf(move) !== -1 || otherBlockedPositions.indexOf(move) !== -1) {
                            break;
                        }
                        else if (checking && this.myKingChecked(move, false)) continue;
                        unblockedPositions.push(move);
                    }
                }
                else {
                    allowedPositions.forEach(allowedPositionsGroup => {
                        for (const move of allowedPositionsGroup) {
                            if (myBlockedPositions.indexOf(move) !== -1) {
                                break;
                            }
                            else if (checking && this.myKingChecked(move)) {
                                if (otherBlockedPositions.indexOf(move) !== -1) {
                                    break;
                                }
                                continue;
                            }
                            unblockedPositions.push(move);

                            if (otherBlockedPositions.indexOf(move) !== -1) {
                                break;
                            }
                        }
                    });
                }

                return this.filterPositions(unblockedPositions);
            }

            getPieceAllowedMoves(pieceName) {
                const piece = this.getPieceByName(pieceName);
                if (this.turn === piece.color) {
                    this.setClickedPiece(piece);

                    let pieceAllowedMoves = getAllowedMoves(piece);
                    if (piece.rank === 'king') {
                        pieceAllowedMoves = this.getCastlingSquares(piece, pieceAllowedMoves);
                    }

                    return this.unblockedPositions(piece, pieceAllowedMoves, true);
                }
                else {
                    return [];
                }
            }

            getCastlingSquares(king, allowedMoves) {
                if (!king.ableToCastle || this.king_checked(this.turn)) return allowedMoves;
                const rook1 = this.getPieceByName(this.turn + 'Rook1');
                const rook2 = this.getPieceByName(this.turn + 'Rook2');
                if (rook1 && rook1.ableToCastle) {
                    const castlingPosition = rook1.position + 2
                    if (
                        !this.positionHasExistingPiece(castlingPosition - 1) &&
                        !this.positionHasExistingPiece(castlingPosition) && !this.myKingChecked(castlingPosition, true) &&
                        !this.positionHasExistingPiece(castlingPosition + 1) && !this.myKingChecked(castlingPosition + 1, true)
                    )
                        allowedMoves[1].push(castlingPosition);
                }
                if (rook2 && rook2.ableToCastle) {
                    const castlingPosition = rook2.position - 1;
                    if (
                        !this.positionHasExistingPiece(castlingPosition - 1) && !this.myKingChecked(castlingPosition - 1, true) &&
                        !this.positionHasExistingPiece(castlingPosition) && !this.myKingChecked(castlingPosition, true)
                    )
                        allowedMoves[0].push(castlingPosition);
                }
                return allowedMoves;
            }

            getPieceByName(piecename) {
                for (const piece of this.pieces) {
                    if (piece.name === piecename) {
                        return piece;
                    }
                }
            }

            getPieceByPos(position) {
                for (const piece of this.pieces) {
                    if (piece.position == position) {
                        return piece;
                    }
                }
            }

            positionHasExistingPiece(position) {
                return this.getPieceByPos(position) !== undefined;
            }

            setClickedPiece(piece) {
                this.clickedPiece = piece;
            }

            triggerEvent(eventName, params) {
                if (this._events[eventName]) {
                    for (const cb of this._events[eventName]) {
                        cb(params);
                    }
                }
            }

            movePiece(pieceName, position) {
                const piece = this.getPieceByName(pieceName);

                position = parseInt(position);

                if (piece && this.getPieceAllowedMoves(piece.name).indexOf(position) !== -1) {
                    const prevPosition = piece.position;
                    const existedPiece = this.getPieceByPos(position)

                    if (existedPiece) {
                        this.kill(existedPiece);
                    }

                    const castling = !existedPiece && piece.rank === 'king' && piece.ableToCastle === true;

                    if (castling) {
                        if (position - prevPosition === 2) {
                            this.castleRook(piece.color + 'Rook2');
                        }
                        else if (position - prevPosition === -2) {
                            this.castleRook(piece.color + 'Rook1');
                        }
                        changePosition(piece, position, true);
                    }
                    else {
                        changePosition(piece, position);
                    }

                    const move = { from: prevPosition, to: position, piece: piece, castling };
                    this.addToHistory(move);
                    this.triggerEvent('pieceMove', move);

                    if (piece.rank === 'pawn' && (position > 80 || position < 20)) {
                        this.promote(piece);
                    }

                    this.changeTurn();

                    if (this.king_checked(this.turn)) {
                        this.triggerEvent('check', this.turn);

                        if (this.king_dead(this.turn)) {
                            this.checkmate(piece.color);
                        }
                        else {
                            // alert('check');
                        }
                    }

                    return true;
                }
                else {
                    return false;
                }
            }

            kill(piece) {
                this._removePiece(piece);
                this.addToHistory({ from: piece.position, to: 0, piece: piece });
                this.triggerEvent('kill', piece);
            }

            castleRook(rookName) {
                const rook = this.getPieceByName(rookName);
                const prevPosition = rook.position;
                const newPosition = rookName.indexOf('Rook2') !== -1 ? rook.position - 2 : rook.position + 3;

                changePosition(rook, newPosition);
                const move = { from: prevPosition, to: newPosition, piece: rook, castling: true };
                this.triggerEvent('pieceMove', move);
                this.addToHistory(move);
            }

            promote(pawn) {
                pawn.name = pawn.name.replace('Pawn', 'Queen');
                pawn.rank = 'queen';
                this.addToHistory({ from: 0, to: pawn.position, piece: pawn });
                this.triggerEvent('promotion', pawn);
            }

            myKingChecked(pos, kill = true) {
                const piece = this.clickedPiece;
                const originalPosition = piece.position;
                const otherPiece = this.getPieceByPos(pos);
                const should_kill_other_piece = kill && otherPiece && otherPiece.rank !== 'king';
                changePosition(piece, pos);
                if (should_kill_other_piece) {
                    this._removePiece(otherPiece);
                }
                if (this.king_checked(piece.color)) {
                    changePosition(piece, originalPosition);
                    if (should_kill_other_piece) {
                        this._addPiece(otherPiece);
                    }
                    return 1;
                }
                else {
                    changePosition(piece, originalPosition);
                    if (should_kill_other_piece) {
                        this._addPiece(otherPiece);
                    }
                    return 0;
                }
            }

            king_dead(color) {
                const pieces = this.getPiecesByColor(color);
                for (const piece of pieces) {
                    this.setClickedPiece(piece);
                    const allowedMoves = this.unblockedPositions(piece, getAllowedMoves(piece), true);
                    if (allowedMoves.length) {
                        this.setClickedPiece(null);
                        return 0;
                    }
                }
                this.setClickedPiece(null);
                return 1;
            }

            king_checked(color) {
                const piece = this.clickedPiece;
                const king = this.getPieceByName(color + 'King');
                const enemyColor = (color === 'white') ? 'black' : 'white';
                const enemyPieces = this.getPiecesByColor(enemyColor);
                for (const enemyPiece of enemyPieces) {
                    this.setClickedPiece(enemyPiece);
                    const allowedMoves = this.unblockedPositions(enemyPiece, getAllowedMoves(enemyPiece), false);
                    if (allowedMoves.indexOf(king.position) !== -1) {
                        this.setClickedPiece(piece);
                        return 1;
                    }
                }
                this.setClickedPiece(piece);
                return 0;
            }

            checkmate(color) {
                this.triggerEvent('checkMate', color);
                this.clearEvents();
            }
        }

        // --- SimulationGame.js content ---
        class SimulationGame extends Game {

            startNewGame(pieces, turn) {
                this._setPieces(pieces);
                this.turn = turn;
                this.clickedPiece = null;
            }

            saveHistory() { }

            addToHistory(move) { }

            triggerEvent(eventName, params) { }

            clearEvents() { }

            undo() { }

            getPieceAllowedMoves(pieceName) {
                const piece = this.getPieceByName(pieceName);
                if (piece && this.turn === piece.color) {
                    this.setClickedPiece(piece);

                    let pieceAllowedMoves = getAllowedMoves(piece);
                    if (piece.rank === 'king') {
                        pieceAllowedMoves = this.getCastlingSquares(piece, pieceAllowedMoves);
                    }

                    return this.unblockedPositions(piece, pieceAllowedMoves, true);
                }
                else {
                    return [];
                }
            }

            movePiece(pieceName, position) {
                const piece = this.getPieceByName(pieceName);

                /*if (!piece) {
                    return false;
                }*/

                const prevPosition = piece.position;
                const existedPiece = this.getPieceByPos(position)

                if (existedPiece) {
                    this.kill(existedPiece);
                }

                const castling = !existedPiece && piece.rank === 'king' && piece.ableToCastle === true;

                if (castling) {
                    if (position - prevPosition === 2) {
                        this.castleRook(piece.color + 'Rook2');
                    }
                    else if (position - prevPosition === -2) {
                        this.castleRook(piece.color + 'Rook1');
                    }
                    changePosition(piece, position, true);
                }
                else {
                    changePosition(piece, position);
                }

                if (piece.rank === 'pawn' && (position > 80 || position < 20)) {
                    this.promote(piece);
                }

                // this.history.add({ from: prevPosition, to: position, piece: piece, castling });
                this.changeTurn();

                return true;
            }

            king_checked(color) {
                const piece = this.clickedPiece;
                const king = this.getPieceByName(color + 'King');
                if (!king) {
                    return true;
                }
                const enemyColor = (color === 'white') ? 'black' : 'white';
                const enemyPieces = this.getPiecesByColor(enemyColor);
                for (const enemyPiece of enemyPieces) {
                    this.setClickedPiece(enemyPiece);
                    const allowedMoves = this.unblockedPositions(enemyPiece, getAllowedMoves(enemyPiece), false);
                    if (allowedMoves.indexOf(king.position) !== -1) {
                        this.setClickedPiece(piece);
                        return 1;
                    }
                }
                this.setClickedPiece(piece);
                return 0;
            }

            checkmate(color) { }
        }

        // --- ai.js content ---
        const ai = (aiTurn) => {
            const ranks = { pawn: 1, king: 2, bishop: 3, knight: 3, rook: 5, queen: 9 };

            const simulationGame = new SimulationGame([], 'white');

            const deepest = 3;

            const humanTurn = aiTurn === 'white' ? 'black' : 'white';

            const middleSquares = [44, 45, 54, 55];
            const widerMiddleSquares = [43, 46, 53, 56];

            const isPieceInMiddle = piece => middleSquares.indexOf(piece.position) !== -1;
            const isPieceInWiderMiddle = piece => widerMiddleSquares.indexOf(piece.position) !== -1;

            const score = pieces => {
                return pieces.reduce((total, piece) => {
                    let weight = piece.color === aiTurn ? ranks[piece.rank] : -1 * ranks[piece.rank];
                    if (isPieceInMiddle(piece)) {
                        weight *= 1.05;
                    }
                    else if (isPieceInWiderMiddle(piece)) {
                        weight *= 1.02;
                    }
                    total += weight;
                    return total;
                }, 0);
            }

            const isBetterScore = (score1, score2, turn) => turn === aiTurn ? score1 >= score2 : score1 <= score2;

            const isScoreGoodEnough = (score, turn) => turn === aiTurn ? score > 7 : score < -7;

            const minimax = (pieces, turn, depth = 0) => {
                simulationGame.startNewGame(pieces, turn);

                if (!simulationGame.getPieceByName(humanTurn + 'King') || simulationGame.king_dead(humanTurn)) {
                    return { score: -Infinity, depth };
                }
                if (!simulationGame.getPieceByName(aiTurn + 'King') || simulationGame.king_dead(aiTurn)) {
                    return { score: Infinity, depth };
                }

                let bestPlay = { move: null, score: turn === aiTurn ? -Infinity : Infinity };

                for (const piece of pieces) {
                    const allowedMoves = simulationGame.getPieceAllowedMoves(piece.name);

                    for (const move of allowedMoves) {

                        const currentTestPlayInfo = {};

                        currentTestPlayInfo.move = { pieceName: piece.name, position: move };
                        simulationGame.movePiece(piece.name, move);

                        const curScore = score(simulationGame.pieces);

                        if (depth === deepest || isBetterScore(bestPlay.score, curScore, turn) || isScoreGoodEnough(curScore, turn)) {
                            currentTestPlayInfo.score = curScore;
                        }
                        else if (turn === aiTurn) {
                            const result = minimax(simulationGame.pieces, humanTurn, depth + 1);
                            currentTestPlayInfo.score = result.score;
                        } else {
                            const result = minimax(simulationGame.pieces, aiTurn, depth + 1);
                            currentTestPlayInfo.score = result.score;
                        }

                        if (isBetterScore(currentTestPlayInfo.score, bestPlay.score, turn)) {
                            bestPlay.move = currentTestPlayInfo.move;
                            bestPlay.score = currentTestPlayInfo.score;
                        }

                        simulationGame.startNewGame(pieces, turn);
                    }
                }

                return bestPlay;
            }

            let play;

            if (isTestEnv()) {
                play = (pieces, callback) => {
                    setTimeout(() => {
                        testFuncTime(() => {
                            const aiPlay = minimax(pieces, aiTurn);
                            callback(aiPlay);
                        });
                    }, 100);
                }
            }
            else {
                play = (pieces, callback) => {
                    setTimeout(() => {
                        const aiPlay = minimax(pieces, aiTurn);
                        callback(aiPlay);
                    }, 100);
                }
            }

            return {
                play
            }
        }

        const isTestEnv = function () {
            const url = new URL(location.href);
            const params = new URLSearchParams(url.searchParams);
            return Boolean(params.get('testing'))
        }

        const testFuncTime = func => {
            const label = 'Timer ' + Date.now();
            console.time(label);
            console.log('Output:', func());
            console.timeLog(label);
        }

        // --- Board.js content ---
        const startBoard = (game, options = { playAgainst: 'human', aiColor: 'black', aiLevel: 'dumb' }) => {

            const aiPlayer = options.playAgainst === 'ai' ? ai(options.aiColor) : null;

            const board = document.getElementById('board');
            const squares = board.querySelectorAll('.square');
            const whiteSematary = document.getElementById('whiteSematary');
            const blackSematary = document.getElementById('blackSematary');
            const turnSign = document.getElementById('turn');
            let clickedPieceName;
            let gameState;

            const resetSematary = () => {
                whiteSematary.querySelectorAll('div').forEach(div => div.innerHTML = '');
                blackSematary.querySelectorAll('div').forEach(div => div.innerHTML = '');
            }

            const resetBoard = () => {
                resetSematary();

                for (const square of squares) {
                    square.innerHTML = '';
                }

                for (const piece of game.pieces) {
                    const square = document.getElementById(piece.position);
                    square.innerHTML = `<img class="piece ${piece.rank}" id="${piece.name}" src="img/${piece.color}-${piece.rank}.webp">`;
                }

                document.getElementById('endscene').classList.remove('show');
            }

            resetBoard();

            const setGameState = state => {
                gameState = state;
                if (gameState === 'ai_thinking') {
                    turnSign.innerHTML += ' (thinking...)';
                }
            }

            const setAllowedSquares = (pieceImg) => {
                clickedPieceName = pieceImg.id;
                const allowedMoves = game.getPieceAllowedMoves(clickedPieceName);
                if (allowedMoves) {
                    const clickedSquare = pieceImg.parentNode;
                    clickedSquare.classList.add('clicked-square');

                    allowedMoves.forEach(allowedMove => {
                        if (document.contains(document.getElementById(allowedMove))) {
                            document.getElementById(allowedMove).classList.add('allowed');
                        }
                    });
                }
                else {
                    clearSquares();
                }
            }

            const clearSquares = () => {
                board.querySelectorAll('.allowed').forEach(allowedSquare => allowedSquare.classList.remove('allowed'));

                const clickedSquare = document.getElementsByClassName('clicked-square')[0];
                if (clickedSquare) {
                    clickedSquare.classList.remove('clicked-square');
                }
            }

            const setLastMoveSquares = (from, to) => {
                document.querySelectorAll('.last-move').forEach(lastMoveSquare => lastMoveSquare.classList.remove('last-move'));
                from.classList.add('last-move');
                to.classList.add('last-move');
            }

            function movePiece(square) {
                if (gameState === 'ai_thinking') {
                    return;
                }

                const position = square.getAttribute('id');
                const existedPiece = game.getPieceByPos(position);

                if (existedPiece && existedPiece.color === game.turn) {
                    const pieceImg = document.getElementById(existedPiece.name);
                    clearSquares();
                    return setAllowedSquares(pieceImg);
                }

                game.movePiece(clickedPieceName, position);
            }

            squares.forEach(square => {
                square.addEventListener("click", function () {
                    movePiece(this);
                });
                square.addEventListener("dragover", function (event) {
                    event.preventDefault();
                });
                square.addEventListener("drop", function () {
                    movePiece(this);
                });
            });

            game.pieces.forEach(piece => {
                const pieceImg = document.getElementById(piece.name);
                if (pieceImg) { // Check if the piece image exists before adding event listener
                    pieceImg.addEventListener("drop", function () {
                        const square = document.getElementById(piece.position);
                        movePiece(square);
                    });
                }
            });

            document.querySelectorAll('img.piece').forEach(pieceImg => {
                pieceImg.addEventListener("dragstart", function (event) {
                    if (gameState === 'ai_thinking') {
                        return;
                    }
                    event.stopPropagation();
                    event.dataTransfer.setData("text", event.target.id);
                    clearSquares();
                    setAllowedSquares(event.target)
                });
                pieceImg.addEventListener("drop", function (event) {
                    if (gameState === 'ai_thinking') {
                        return;
                    }
                    event.stopPropagation();
                    clearSquares();
                    setAllowedSquares(event.target)
                });
            });

            const startTurn = turn => {
                gameState = turn + '_turn';
                turnSign.innerHTML = turn === 'white' ? "White's Turn" : "Black's Turn";

                if (gameState !== 'checkmate' && options.playAgainst === 'ai' && turn === options.aiColor) {
                    setGameState('ai_thinking');
                    aiPlayer.play(game.pieces, aiPlay => {
                        setGameState('human_turn');
                        game.movePiece(aiPlay.move.pieceName, aiPlay.move.position);
                    });
                }
            }

            game.on('pieceMove', move => {
                const from = document.getElementById(move.from);
                const to = document.getElementById(move.piece.position);
                to.append(document.getElementById(move.piece.name));
                clearSquares();

                setLastMoveSquares(from, to);
            });

            game.on('turnChange', startTurn);

            game.on('promotion', queen => {
                const square = document.getElementById(queen.position);
                square.innerHTML = `<img class="piece queen" id="${queen.name}" src="img/${queen.color}-queen.webp">`;
            })

            game.on('kill', piece => {
                const pieceImg = document.getElementById(piece.name);
                pieceImg.parentNode.removeChild(pieceImg);
                pieceImg.className = '';

                const sematary = piece.color === 'white' ? whiteSematary : blackSematary;
                sematary.querySelector('.' + piece.rank).append(pieceImg);
            });

            game.on('checkMate', color => {
                const endScene = document.getElementById('endscene');
                endScene.getElementsByClassName('winning-sign')[0].innerHTML = color + ' Wins';
                endScene.classList.add('show');
                setGameState('checkmate');
            });

            startTurn('white');
        }

        const pieces = [
            { rank: 'knight', position: 12, color: 'white', name: 'whiteKnight1' },
            { rank: 'knight', position: 17, color: 'white', name: 'whiteKnight2' },
            { rank: 'queen', position: 14, color: 'white', name: 'whiteQueen' },
            { rank: 'bishop', position: 13, color: 'white', name: 'whiteBishop1' },
            { rank: 'bishop', position: 16, color: 'white', name: 'whiteBishop2' },
            { rank: 'pawn', position: 24, color: 'white', name: 'whitePawn4' },
            { rank: 'pawn', position: 25, color: 'white', name: 'whitePawn5' },
            { rank: 'pawn', position: 26, color: 'white', name: 'whitePawn6' },
            { rank: 'pawn', position: 21, color: 'white', name: 'whitePawn1' },
            { rank: 'pawn', position: 22, color: 'white', name: 'whitePawn2' },
            { rank: 'pawn', position: 23, color: 'white', name: 'whitePawn3' },
            { rank: 'pawn', position: 27, color: 'white', name: 'whitePawn7' },
            { rank: 'pawn', position: 28, color: 'white', name: 'whitePawn8' },
            { rank: 'rook', position: 11, color: 'white', name: 'whiteRook1', ableToCastle: true },
            { rank: 'rook', position: 18, color: 'white', name: 'whiteRook2', ableToCastle: true },
            { rank: 'king', position: 15, color: 'white', name: 'whiteKing', ableToCastle: true },

            { rank: 'knight', position: 82, color: 'black', name: 'blackKnight1' },
            { rank: 'knight', position: 87, color: 'black', name: 'blackKnight2' },
            { rank: 'queen', position: 84, color: 'black', name: 'blackQueen' },
            { rank: 'bishop', position: 83, color: 'black', name: 'blackBishop1' },
            { rank: 'bishop', position: 86, color: 'black', name: 'blackBishop2' },
            { rank: 'pawn', position: 74, color: 'black', name: 'blackPawn4' },
            { rank: 'pawn', position: 75, color: 'black', name: 'blackPawn5' },
            { rank: 'pawn', position: 76, color: 'black', name: 'blackPawn6' },
            { rank: 'pawn', position: 71, color: 'black', name: 'blackPawn1' },
            { rank: 'pawn', position: 72, color: 'black', name: 'blackPawn2' },
            { rank: 'pawn', position: 73, color: 'black', name: 'blackPawn3' },
            { rank: 'pawn', position: 77, color: 'black', name: 'blackPawn7' },
            { rank: 'pawn', position: 78, color: 'black', name: 'blackPawn8' },
            { rank: 'rook', position: 81, color: 'black', name: 'blackRook1', ableToCastle: true },
            { rank: 'rook', position: 88, color: 'black', name: 'blackRook2', ableToCastle: true },
            { rank: 'king', position: 85, color: 'black', name: 'blackKing', ableToCastle: true },
        ];
        const game = new Game(pieces, 'white');

        const startNewGame = () => {
            document.querySelectorAll('.scene').forEach(scene => scene.classList.remove('show'));

            const playAgainst = document.querySelector('input[name="oponent"]:checked').value;
            const humanColor = document.querySelector('input[name="human_color"]:checked')?.value;
            const aiColor = humanColor === 'white' ? 'black' : 'white';
            const aiLevel = 'dumb';

            startBoard(game, { playAgainst, aiColor, aiLevel });
        }

        const showColorSelect = () => document.querySelector('.select-color-container').classList.add('show');
        const hideColorSelect = () => document.querySelector('.select-color-container').classList.remove('show');

        // --- Inline script from original chess.html ---
        const boardAnimate = () => {
            const board = document.getElementById('board');
            const elements = board.getElementsByClassName('piece');
            if (board.classList.contains('animate')) {
                board.classList.remove('animate');
                board.classList.add('animate-backward');
                for (element of elements) {
                    element.classList.remove('forward');
                    element.classList.add('backward');
                }
            }
            else {
                board.classList.remove('animate-backward');
                board.classList.add('animate');
                for (element of elements) {
                    element.classList.remove('backward');
                    element.classList.add('forward');
                }
            }
        }

        const changeColorSelect = () => {
            const playAgainst = document.querySelector('input[name="oponent"]:checked').value;
            if (playAgainst === 'ai') {
                showColorSelect();
            }
            else {
                hideColorSelect();
            }
        }

        changeColorSelect();
    </script>

</body>

</html>
