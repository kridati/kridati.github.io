<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1QSWB91R8H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1QSWB91R8H');
</script>
<!-- google adsense -->>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5879206576649841"
     crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Car Racer 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            touch-action: none;
            background: #4a5568; /* Tailwind gray-700 */
        }

        /* Game container uses Flexbox to center everything */
        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: #1a202c; /* Tailwind gray-900 */
        }
        
        /* Game Frame holds all dynamic elements (Canvas, UI, Controls) */
        #gameFrame {
            position: relative; 
            /* Size and position will be set by JS for 9:16 ratio and centering */
            overflow: hidden; /* Important for clean edges */
        }

        /* UI Elements positioned absolutely inside gameFrame */
        #uiContainer {
            position: absolute;
            top: 0; /* Ensures it sticks to the top of gameFrame */
            left: 0;
            z-index: 20;
            padding-top: 0 !important; /* Force minimal padding at top */
            padding-bottom: 5px; /* Minimal padding at bottom */
        }

        /* Touch controls overlay positioned absolutely inside gameFrame */
        #touchControls {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            z-index: 25; 
        }

        #leftControl, #rightControl {
            height: 100%;
            display: flex; 
            justify-content: center; 
            align-items: flex-start; /* Aligned to the top of the controls div */
            cursor: pointer;
            padding-top: 0; /* Reset default padding */
        }

        .control-arrow {
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8; 
            color: white;
            width: 50px; 
            height: 50px;
            background-color: rgba(59, 130, 246, 0.7); 
            border-radius: 50%; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.1s;
        }

        .control-arrow:active {
            background-color: rgba(59, 130, 246, 1);
        }
        
        /* Modal styling */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 30;
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">

    <div id="gameContainer">
        
        <div id="gameFrame">
            
            <!-- Score and Title - FIX: Removed style attribute and used CSS padding properties for top alignment -->
            <div id="uiContainer" class="px-4 flex justify-between items-center">
                <h1 class="text-2xl font-bold" style="top: 0px;
    position: absolute;
    left: 0;">Car Racer 2D</h1>
                <div class="text-2xl font-bold" style="position: absolute;
    top: 0;
    right: 0;">
                    Score: <span id="scoreDisplay">0</span>
                </div>
            </div>
    
            <!-- Canvas (Road) -->
            <canvas id="gameCanvas"></canvas>
    
            <!-- Touch/Mouse Controls -->
            <div id="touchControls">
                <div id="leftControl">
                    <div class="control-arrow" id="leftArrow">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="30" height="30">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </div>
                </div>
                <div id="rightControl">
                    <div class="control-arrow" id="rightArrow">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="30" height="30">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                        </svg>
                    </div>
                </div>
            </div>
            
        </div>


        <!-- Game Over / Start Modal -->
        <div id="modal" class="modal bg-gray-800 p-8 rounded-lg shadow-xl text-center hidden">
            <h2 id="modalTitle" class="text-2xl font-bold mb-3">Car Racer 2D</h2>
            <p id="modalSubTitle" class="text-lg mb-6 text-gray-400">Tap to dodge traffic!</p>
            <button id="homeButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg text-xl mb-3 transition duration-200">
                Home
            </button>
            <button id="startButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-200">
                Start Game
            </button>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameContainer = document.getElementById('gameContainer');
            const gameFrame = document.getElementById('gameFrame');

            // UI Elements
            const scoreDisplay = document.getElementById('scoreDisplay');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modalTitle');
            const modalSubTitle = document.getElementById('modalSubTitle');
            const startButton = document.getElementById('startButton');
            const homeButton = document.getElementById('homeButton');

            // Control Elements
            const uiContainer = document.getElementById('uiContainer');
            const touchControls = document.getElementById('touchControls');
            const leftControl = document.getElementById('leftControl');
            const rightControl = document.getElementById('rightControl');

            let gameWidth, gameHeight;
            let obstacles, roadLines;
            let score, gameSpeed, isGameRunning, animationFrameId;

            // Player state
            let currentPlayerLane = 1; // 0 = left, 1 = middle, 2 = right
            let targetX = 0;

            // Tone.js State
            let isToneInitialized = false;
            let synth, crashSynth, laneSynth, musicLoop;

            // Game settings
            const playerWidthRatio = 0.12; 
            const playerHeightRatio = 0.08; 
            const obstacleSpeedStart = 3.5; 
            const roadLineWidth = 5;
            const roadLineHeight = 30;
            const roadLineGap = 20;

            // Player object
            const playerCar = {
                width: 50,
                height: 80,
                x: 0,
                y: 0,
                speed: 5,
                color: '#ef4444' // Tailwind red-500
            };

            // --- Tone.js Audio Setup ---

            function initTone() {
                if (isToneInitialized) return;

                // 1. Background Music Synth (8-bit style)
                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "square" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 1
                    }
                }).toDestination();
                
                // 2. Crash SFX Synth (Noise burst)
                crashSynth = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0.0,
                        release: 0.1
                    }
                }).toDestination();

                // 3. Lane Change SFX (Quick 'click')
                laneSynth = new Tone.MembraneSynth().toDestination();

                // Music Loop Logic (A simple, rhythmic loop)
                const pattern = ["C4", "G3", "A3", "F3"];
                let index = 0;

                musicLoop = new Tone.Loop(time => {
                    if (isGameRunning) {
                        synth.triggerAttackRelease(pattern[index % pattern.length], "8n", time);
                        index++;
                    }
                }, "4n").start(0); 

                Tone.Transport.bpm.value = 120; 
                
                isToneInitialized = true;
            }

            async function startAudio() {
                if (!isToneInitialized) initTone();
                
                // Ensure audio context is running on user interaction
                await Tone.start(); 

                // Start transport only when game runs
                Tone.Transport.start(); 
            }

            function stopAudio() {
                Tone.Transport.stop();
            }

            function playLaneChangeSfx() {
                if (isToneInitialized) {
                    laneSynth.triggerAttackRelease("C5", "16n");
                }
            }

            function playCrashSfx() {
                if (isToneInitialized) {
                    crashSynth.triggerAttackRelease("4n");
                }
            }

            // --- Game Functions ---

            function init() {
                resizeCanvas();
                showModal('Car Racer 2D', 'Tap to dodge traffic!');
                startButton.onclick = startGame;
                homeButton.onclick = () => { window.location.href = 'index.html'; };

                // Add mouse/touch event listeners for controls
                const handleControl = (e) => {
                    e.preventDefault();
                    e.stopImmediatePropagation(); 
                    
                    if (!isGameRunning) return;

                    const target = e.currentTarget;
                    if (target.id === 'leftControl' && currentPlayerLane > 0) {
                        currentPlayerLane--;
                        playLaneChangeSfx();
                    } else if (target.id === 'rightControl' && currentPlayerLane < 2) {
                        currentPlayerLane++;
                        playLaneChangeSfx();
                    }
                };

                // PC Mouse Click (using mouseup for reliability)
                leftControl.addEventListener('mouseup', handleControl);
                rightControl.addEventListener('mouseup', handleControl);

                // Mobile Touch
                leftControl.addEventListener('touchstart', handleControl, { passive: false });
                rightControl.addEventListener('touchstart', handleControl, { passive: false });
                
                window.addEventListener('resize', resizeCanvas);
                
                initTone();
            }

            async function startGame() {
                await startAudio();

                score = 0;
                gameSpeed = obstacleSpeedStart;
                isGameRunning = true;
                obstacles = [];
                roadLines = [];
                scoreDisplay.textContent = '0';
                modal.classList.add('hidden');

                // Initial player setup
                playerCar.width = gameWidth * playerWidthRatio;
                playerCar.height = gameHeight * playerHeightRatio;
                
                currentPlayerLane = 1; 
                const laneWidth = gameWidth / 3;
                playerCar.x = (currentPlayerLane * laneWidth) + (laneWidth / 2) - (playerCar.width / 2);
                targetX = playerCar.x;
                
                // Player fixed 25% up from bottom
                playerCar.y = gameHeight * 0.75 - (playerCar.height / 2); 
                playerCar.speed = gameWidth * 0.04; 

                // Initial road lines (overfill to ensure continuous appearance)
                for (let i = 0; i < (gameHeight / (roadLineHeight + roadLineGap)) + 2; i++) {
                    roadLines.push({
                        y: i * (roadLineHeight + roadLineGap)
                    });
                }
                
                spawnObstacle();

                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                gameLoop();
            }

            function gameOver() {
                isGameRunning = false;
                cancelAnimationFrame(animationFrameId);
                stopAudio();
                playCrashSfx();
                showModal('Game Over', `Final Score: ${score}`);
            }

            function showModal(title, scoreText) {
                modalTitle.textContent = title;
                modalSubTitle.textContent = scoreText;
                if (title === 'Game Over') {
                    startButton.textContent = 'Restart Game';
                } else {
                    startButton.textContent = 'Start Game';
                }
                modal.classList.remove('hidden');
            }

            function resizeCanvas() {
                const ratio = 9 / 16;
                const containerWidth = gameContainer.clientWidth;
                const containerHeight = gameContainer.clientHeight;
                
                let calculatedWidth, calculatedHeight;

                if (containerWidth / containerHeight > ratio) {
                    calculatedHeight = containerHeight;
                    calculatedWidth = containerHeight * ratio;
                } else {
                    calculatedWidth = containerWidth;
                    calculatedHeight = containerWidth / ratio;
                }

                gameWidth = calculatedWidth;
                gameHeight = calculatedHeight;
                
                // Set the size of the main frame (9:16 aspect ratio)
                gameFrame.style.width = `${gameWidth}px`;
                gameFrame.style.height = `${gameHeight}px`;

                // Set canvas size
                canvas.width = gameWidth;
                canvas.height = gameHeight;
                canvas.style.width = `${gameWidth}px`;
                canvas.style.height = `${gameHeight}px`;

                // Set UI and Touch Controls size (to match the frame size)
                uiContainer.style.width = `${gameWidth}px`;
                uiContainer.style.height = `${gameHeight}px`;
                touchControls.style.width = `${gameWidth}px`;
                touchControls.style.height = `${gameHeight}px`;

                leftControl.style.width = `${gameWidth / 2}px`;
                rightControl.style.width = `${gameWidth / 2}px`;
                
                // Set control arrow position dynamically (aligned with player car)
                // Player is at 75% of game height (gameHeight * 0.75)
                // We align the center of the 50px arrow circle (25px radius) to this line
                const arrowTopPosition = gameHeight * 0.75 - 25; 
                document.querySelectorAll('#leftArrow, #rightArrow').forEach(arrow => {
                    arrow.style.marginTop = `${arrowTopPosition}px`;
                });

                if (isGameRunning) {
                    playerCar.height = gameHeight * playerHeightRatio;
                    playerCar.width = gameWidth * playerWidthRatio;
                    
                    playerCar.y = gameHeight * 0.75 - (playerCar.height / 2); 
                    playerCar.speed = gameWidth * 0.04;
                    
                    const laneWidth = gameWidth / 3;
                    targetX = (currentPlayerLane * laneWidth) + (laneWidth / 2) - (playerCar.width / 2);
                    playerCar.x = targetX;
                }
            }

            function gameLoop() {
                if (!isGameRunning) return;

                // 1. Clear canvas
                ctx.clearRect(0, 0, gameWidth, gameHeight);

                // 2. Draw Road & Lines
                drawRoad();

                // 3. Update & Draw Player
                updatePlayer();
                drawCarShape(playerCar, true); // Player Car

                // 4. Update & Draw Obstacles
                updateObstacles();
                
                // 5. Update Score
                scoreDisplay.textContent = score;
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function drawRoad() {
                ctx.fillStyle = '#4a5568'; 
                ctx.fillRect(0, 0, gameWidth, gameHeight);

                ctx.fillStyle = '#cbd5e0'; 
                const laneWidth = gameWidth / 3;
                
                let minY = gameHeight * 2; 
                
                roadLines.forEach(line => {
                    ctx.fillRect(laneWidth - (roadLineWidth / 2), line.y, roadLineWidth, roadLineHeight);
                    ctx.fillRect((laneWidth * 2) - (roadLineWidth / 2), line.y, roadLineWidth, roadLineHeight);
                    
                    line.y += gameSpeed;

                    if (line.y < minY) {
                        minY = line.y;
                    }
                });
                
                // Recycle lines
                roadLines.forEach(line => {
                    if (line.y > gameHeight) {
                        line.y = minY - (roadLineHeight + roadLineGap);
                        minY = line.y;
                    }
                });
            }

            function updatePlayer() {
                const laneWidth = gameWidth / 3;
                targetX = (currentPlayerLane * laneWidth) + (laneWidth / 2) - (playerCar.width / 2);

                const dx = targetX - playerCar.x;

                if (Math.abs(dx) < playerCar.speed) {
                    playerCar.x = targetX;
                } else if (dx > 0) {
                    playerCar.x += playerCar.speed;
                } else if (dx < 0) {
                    playerCar.x -= playerCar.speed;
                }
            }

            function updateObstacles() {
                gameSpeed = obstacleSpeedStart + (score * 0.15); 
                
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    obs.y += gameSpeed;

                    drawCarShape(obs, false); 

                    if (checkCollision(playerCar, obs)) {
                        gameOver();
                        return;
                    }

                    if (obs.y > gameHeight) {
                        obstacles.splice(i, 1);
                        score++;
                    }
                }
            }
            
            function spawnObstacle() {
                if (!isGameRunning) return;

                const obstacleWidth = playerCar.width * (0.9 + Math.random() * 0.2); 
                const obstacleHeight = playerCar.height * (0.9 + Math.random() * 0.2); 
                
                const laneWidth = gameWidth / 3;
                const lane = Math.floor(Math.random() * 3); 
                const x = (lane * laneWidth) + (laneWidth / 2) - (obstacleWidth / 2);

                const y = -obstacleHeight - (gameHeight * 0.1); 
                const colors = ['#3b82f6', '#10b981', '#f59e0b', '#6366f1', '#e879f9', '#f97316']; 
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                obstacles.push({
                    width: obstacleWidth,
                    height: obstacleHeight,
                    x: x,
                    y: y,
                    color: color
                });

                const spawnInterval = Math.max(300, 1500 - (gameSpeed * 100)); 
                setTimeout(spawnObstacle, spawnInterval);
            }

            function drawCarShape(car, isPlayer) {
                const { x, y, width, height, color } = car;
                const cornerRadius = 5;
                
                // --- 1. Base Body with Gradient for 3D Shading ---
                ctx.beginPath();
                ctx.moveTo(x + cornerRadius, y);
                ctx.lineTo(x + width - cornerRadius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
                ctx.lineTo(x + width, y + height - cornerRadius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
                ctx.lineTo(x + cornerRadius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
                ctx.lineTo(x, y + cornerRadius);
                ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                ctx.closePath();

                const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.5, color);
                const darkerColor = color + 'AA';
                gradient.addColorStop(1, darkerColor); 
                
                ctx.fillStyle = gradient;
                ctx.fill();

                // --- 2. Simple Shadow ---
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                ctx.fillRect(x + width * 0.1, y + height - 5, width * 0.8, 5); 
                ctx.shadowBlur = 0; 
                ctx.shadowOffsetY = 0;
                ctx.shadowColor = 'transparent';

                // --- 3. Windows (Windshield and Side Windows) ---
                const windowWidth = width * 0.7;
                const windowHeight = height * 0.3;
                const windowX = x + width * 0.15;
                const windowY = y + height * 0.15;

                ctx.fillStyle = '#4b5563'; 

                // Draw Trapezoid Windshield
                ctx.beginPath();
                ctx.moveTo(windowX, windowY); 
                ctx.lineTo(windowX + windowWidth, windowY); 
                ctx.lineTo(windowX + windowWidth * 0.9, windowY + windowHeight); 
                ctx.lineTo(windowX + windowWidth * 0.1, windowY + windowHeight); 
                ctx.closePath();
                ctx.fill();
                
                // Window Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(windowX + width * 0.05, windowY + 3);
                ctx.lineTo(windowX + windowWidth - width * 0.05, windowY + 3);
                ctx.lineTo(windowX + windowWidth * 0.8, windowY + 5);
                ctx.lineTo(windowX + windowWidth * 0.2, windowY + 5);
                ctx.closePath();
                ctx.fill();

                // --- 4. Wheels ---
                const wheelRadius = width * 0.1;
                const wheelColor = '#2d3748'; 
                const rimColor = '#a0aec0'; 

                const drawWheel = (centerX, centerY, radius, wheelColor, rimColor) => {
                    const offset = 3;
                    const adjustedX = centerX === x ? centerX + offset : centerX - offset;

                    // Tire Outline (for depth)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(adjustedX, centerY, radius + 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Tire
                    ctx.fillStyle = wheelColor;
                    ctx.beginPath();
                    ctx.arc(adjustedX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rim/Hubcap
                    ctx.fillStyle = rimColor;
                    ctx.beginPath();
                    ctx.arc(adjustedX, centerY, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                };

                // Front Left Wheel
                drawWheel(x, y + height * 0.7, wheelRadius, wheelColor, rimColor);
                // Front Right Wheel
                drawWheel(x + width, y + height * 0.7, wheelRadius, wheelColor, rimColor);
                // Rear Left Wheel
                drawWheel(x, y + height * 0.3, wheelRadius, wheelColor, rimColor);
                // Rear Right Wheel
                drawWheel(x + width, y + height * 0.3, wheelRadius, wheelColor, rimColor);

                // Simple Bumper/Spoiler detail
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x + width * 0.1, y + height - 5, width * 0.8, 5);
            }

            function checkCollision(rect1, rect2) {
                return (
                    rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y
                );
            }

            // --- Start the game initialization ---
            init();
        });
    </script>

</body>
</html>

